<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>roehr-lab</title>

	<link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reset.css">
	<link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reveal.css">
	<link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="https://unpkg.com/reveal@0.0.4/plugin/highlight/monokai.css">
	<!-- <script type="importmap">
		{
			"imports": {
				"three": "../three.js/build/three.module.js",
				"three/addons/": "../three.js/examples/jsm/"
			}
		}
	</script> -->

	<script type="importmap">
		{
		  "imports": {
			"three": "https://unpkg.com/three@^0.171.0/build/three.module.js",
					  "three/addons/": "https://unpkg.com/three@^0.171.0/examples/jsm/"
		  }
		}
	  </script>
	<script type="text/javascript" id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
		</script>
	<style>
		.button {
			background-color: #ffffff;
			/* Green */
			border: none;
			color: black;
			padding: 15px 32px;
			text-align: center;
			text-decoration: none;
			display: inline-block;
			font-size: 56px;
			margin: 4px 2px;
			cursor: pointer;
			-webkit-transition-duration: 0.4s;
			/* Safari */
			transition-duration: 0.4s;
		}

		.button1 {
			box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
		}

		.button2:hover {
			box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
		}

		/*=== 1.4. Basic Grid (Flexible blocks)
Auto-fill & Equal height === */
		.grid {
			clear: both;
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-ms-flex-wrap: wrap;
			flex-wrap: wrap;
			margin-left: auto;
			margin-right: auto;
		}

		.grid:after {
			clear: both;
		}

		.grid:before {
			content: '';
			display: table;
		}

		.grid>.column {
			display: -webkit-box;
			display: -ms-flexbox;
			display: flex;
			-webkit-box-flex: 1;
			-ms-flex: auto;
			flex: auto;
			-webkit-box-orient: vertical;
			-webkit-box-direction: normal;
			-ms-flex-direction: column;
			flex-direction: column;
			padding: 0.1rem;
			position: relative;
			-webkit-transition: .3s;
			transition: .3s;
			width: 100%;
		}

		.grid.vertical-align .column {
			-webkit-box-pack: center;
			-ms-flex-pack: center;
			justify-content: center;
		}

		@media (min-width: 768px) {
			.grid>.column {
				width: 15%;
			}

			.grid.sm .column:nth-child(1) {
				width: 30%;
			}

			.grid.sm .column:nth-child(2) {
				width: 70%;
			}

			.grid.ms .column:nth-child(1) {
				width: 70%;
			}

			.grid.ms .column:nth-child(2) {
				width: 30%;
			}

			.grid.sms .column:nth-child(2) {
				width: 50%;
			}
		}

		table,
		th,
		td {
			border: 1px solid black;
		}


		/* .slide-number, */
		/* .reveal.has-logo .slide-number { */
		/* bottom: 14px !important; */
		/* left: 50px !important; */
		/* top: unset !important; */
		/* color: #777777 !important; */
		/* font-size: x-large; */
		/* } */

		.reveal .slide-number {
			font-size: 60pt;
			color: rgb(75, 75, 75);
			background-color: beige;
			left: unset;
			bottom: unset;
			top: 20px;
			right: 20px;
		}

		.reveal div.footer {
			position: absolute;
			bottom: 0;
			left: 0;
			padding: 0;
			margin: 0;
			font-size: medium;
			color: darkblue;
		}

		.reveal .playback{
			width: 200px;
		}
	</style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


</head>

<body>
	<div class="reveal">
		<div class="slides">


			\(
			\def\AA{{\bf &#x212B;}}
			\def\ii{{ &#x1D7D9;}}
			\def\bold#1{{\bf #1}}
			\)

<section data-background-color="white" data-background-image="csm_tube.png" data-background-opacity="0.2">
				<p style="font-size: 5em;">Reohr-Lab</p>
				<div class="grid">
					<div class="column">
						<div class="bg-white shadow" style="left: 80%; font-size:x-large;text-align: left;">

							<div class="wrap">
								<p style="width: 80%; ">We develop and apply theoretical methodology suitable to
									investigate aggregation-induced functions in supramolecular structures in the ground
									and excited state. In particular, we study how supramolecular systems can facilitate
									(photo-)catalytic reactions and how structural motifs effect charge and exciton
									transport. We apply new atomistic dynamics simulation techniques allowing us to gain
									insight into the mechanistic details of these processes. Furthermore, we aim to
									understand how molecular aggregates are formed and thus, how the formation towards
									desired structural motifs can be controlled.</p>
								<p>Dr. Merle I. S. RÃ¶hr </p>
								<p><a  style="color:rgb(17, 59, 59)" href="https://scholar.google.de/citations?user=ZY9LYLwAAAAJ&hl=de"> <u>Google
											Scholar</u> </a></p>
								<p>Telephone: +49 931 31 88832</p>
								<p>E-Mail: merle.roehr@uni-wuerzburg.de</p>
							</div>

						</div>

					</div>


					<div class="column" style="font-size: x-large;text-align: left;">
						<h1>Key Project</h1>
						<h4 ><a style="color:rgb(17, 59, 59)" href="https://github.com/roehr-lab/SFast-Singlet-Fission-adiabatic-basis-screening">
							<i class="fa fa-link" style="color:black"></i>
						SFast-Singlet-Fission-adiabatic-basis-screening</a></h4>
						<h4 ><a style="color:rgb(17, 59, 59)" href="https://github.com/roehr-lab/Functionality_Optimization_for_Effective_SF_Coupling_Screening">
							<i class="fa fa-link" style="color:black"></i>
						Functionality_Optimization_for_Effective_SF_Coupling_Screening</a></h4>
						<h4 ><a style="color:rgb(17, 59, 59)" href="https://github.com/roehr-lab/SymbolicCI">
							<i class="fa fa-link" style="color:black"></i>
						Symbolic CI</a></h4>
						<h4 ><a style="color:rgb(17, 59, 59)" href="https://github.com/roehr-lab/SFLinker">
							<i class="fa fa-link" style="color:black"></i>
						SFLinker</a></h4>
					</div>

				</div>

			</section>


			<section data-background-color="white" data-background-image="nsd/ic1.png">
				<h2>Fragment Molecular Orbital Configuration Interaction
					Methodology for the Description of Correlated States in
					Extended Molecular Aggregates</h2>
					<p>Project of</p>
				<h4>Anurag Singh</h4>
			</section>

			<section data-background-color="white">
				<h2><strong>Project</strong></h2>
				<div class="wrap">

					<div class="grid vertical-align">

						<div class="column">
							<h4>
								Symbolic-CI Software Development
							</h4>
							<div style="height: 100%; background-color: white; ">
								<img class="aligncenter" src="nsd/Point.png" alt="WebSlides Files">
							</div>
						</div>

						<div class="column">
							<h4>
								Singlet Fission model for Trimer
							</h4>
							<div style="height: 100%; background-color: white; ">
								<img class="aligncenter" src="nsd//fig12.png" alt="WebSlides Files">
							</div>
						</div>
						<div class="column">
							<h4>
								SFast Software Development for Dimer
							</h4>
							<div style="height: 100%; background-color: white; ">
								<figure><img class="aligncenter" src="nsd/PBI_abs_full.png" alt="WebSlides Files">
									<img class="aligncenter" src="nsd/PBI_non-adiabatic.png">
								</figure>
							</div>
						</div>
						<div class="column">
							<h4>
								SFast , B-N doping and optimisation
							</h4>
							<div style="height: 100%; background-color: white; ">
								<figure><img class="aligncenter" src="nsd/selected_isomers.png"
										alt="WebSlides Files"></figure>
							</div>
						</div>


					</div>

					<!--end .grid -->
				</div>
			</section>

			<section data-background-color="white">
				<h2>Software Development for Fragment Molecular Orbital base Configuration Interaction </h2>
			</section>
			<section data-background-color="white">
				<h4>Branching Diagram approach to make configuration state function</h4>
				<div class="wrap">
					<div class="grid ">
						<div class="column" id="myCanvasId">
							<div id="igc1">
								<!-- <div id="igc1" style="display: flex; width: 90%; height: 100px; position: relative; flex-direction: row; justify-content: flex-end;"> -->
								<!-- Optional buttons can be uncommented if needed -->
								<!-- <button id="u1" class="button button2">&#xFFE9;</button>
								<h1 id="ni1">4</h1>
								<button id="u2" class="button button2">&#xFFEB;</button> -->
							</div>
						</div>
						<div class="column" style="font-size: x-large; text-align: left;">
							<!-- Main Content -->
							<div id="info">
								<!-- <p style="font-size: 25px;">Slide the slider to get various Spin chain based on S and M
								</p>
								<p style="font-size: 25px;">Press "D" to run animation </p> -->
								<div class="slidecontainer">
									<table style="width:100%;font-size: 25px;">
										<tr>
											<td>Number of electron </td>
											<td> <input type="text" id="nelec" name="lname" value="6"></td>
											<td><span id="nm1">6</span></td>
											<br><br>
										</tr>
										<tr>
											<td>Select the final S</td>
											<td><input type="range" min="0" max="20" value="0" class="slider"
													style="width: 50%;" id="myRange">
											</td>
											<td><span id="nm2">0</span><br></td>
										</tr>
										<tr>
											<td>Select the pathway of S for generting M network </td>
											<td><input type="range" min="0" max="20" value="0" class="slider"
													style="width: 50%;" id="myRange3">
											</td>
											<td><span id="nm3">0</span><br></td>
										</tr>
										<tr>
											<td>Select the pathway of M </td>
											<td><input type="range" min="0" max="20" value="0" class="slider"
													style="width: 50%;" id="myRange4">
											</td>
											<td><span id="nm4">0</span><br></td>
										</tr>
										<tr>
											<td>Select the pathway of final M </td>
											<td><input type="range" min="0" max="20" value="0" class="slider"
													style="width: 50%;" id="myRange5">
											</td>
											<td><span id="nm5">0</span><br></td>

										</tr>
									</table>
									<br><br>
									<button id="myRange2" style="font-size: 25px;">Generate Diagram</button>
									<button class="w3-btn w3-teal" id="getImage" style="font-size: 25px;">Download
										Image</button>
									<!--<button class="w3-btn w3-teal" id="getLatex" >Get Latex</button>-->
									<!-- <p><span id="demo"></span></p>
									<p><span id="demo2"></span></p>
									<div id="root"></div> -->
								</div>
							</div>

							<div id="root" style="position: relative;"></div>
							<!-- <div id="make1" >
								<p class="fragment fade-in" id="equation3">
									\( |\Psi ^{S=1,M=0} \rangle= \substack { \displaystyle { - \frac { 1 }{ \sqrt { 3}}
									|\downarrow\downarrow\uparrow\uparrow \rangle
									+ \frac { 1 }{ \sqrt { 12}} |\downarrow\uparrow\downarrow\uparrow \rangle
									+ \frac { 1 }{ \sqrt { 12}} |\uparrow\downarrow\downarrow\uparrow \rangle }\\
									\displaystyle {- \frac { 1 }{ \sqrt { 12}} |\downarrow\uparrow\uparrow\downarrow
									\rangle
									- \frac { 1 }{ \sqrt { 12}} |\uparrow\downarrow\uparrow\downarrow \rangle
									+ \frac { 1 }{ \sqrt { 3}} |\uparrow\uparrow\downarrow\downarrow \rangle }}\)</p>
							</div> -->
						</div>
					</div>
				</div>

			</section>
			<section data-background-color="white">
				<h3> WaveFunction Construction</h3>
				<div class="wrap">
					<div class="grid">
						<div class="column">
							<div class="bg-white shadow" style="font-size:x-large;text-align: left;">
								
								<div class="diagram">
									<img src="nsd/Spoint.png">

								</div>
								<h3>Wave Function Representation</h3>
								<p>The wave function with spin-only information is transformed as follows:</p>
								<div class="equation">
									<em>Equation:</em> \( \vert \Psi^{S_{pathway}}_{(^{i}s)} \rangle =
									\sum^{M_{pathways}}_{k} CG_{k} \vert s_{1},m_{1} \rangle \otimes ... \vert
									s_{n},m_{n} \rangle \)
								</div>
								<p>Using creation operators, the wave function becomes:</p>
								<div class="equation">
									\( \vert \Psi^{S_{pathway}}_{(^{i}s)} \rangle = \sum^{M_{pathways}}_{k} \sum_{k}
									CG_{k} C^{\dagger}_{\vert s,m\rangle_{j}} ... \vert -\rangle \)
								</div>
							</div>

						</div>


						<div class="column" style="font-size: x-large;">


							<p>
								The Creation and annihilation operator is defined as:
								$$
								a^{\dagger} = \begin{pmatrix}
								0 & 0 \\
								1 & 0
								\end{pmatrix}
								,
								a = \begin{pmatrix}
								0 & 1 \\
								0 & 0
								\end{pmatrix}
								$$
							</p>


							<p>Creation operator for an electron in spatial orbtal \( \psi
								\)
							</p>
							<p>
								\(\textbf{a}^{\dagger}_{\sigma \psi} = (\mathbf{s} \otimes ....\otimes
								\mathbf{s}
								\otimes
								a^{\dagger}_{\sigma } \otimes \unicode{x1D7D9}^{2} \otimes .... \otimes
								\unicode{x1D7D9}^{2})\psi.
								\)
							</p>
							\begin{equation}
							\begin{split}
							\left\langle\Psi_{m}\right|\hat{H}\left|\Psi_{n}\right\rangle = \sum_{i,j =
							1}^{d}\sum_{s_{i},s_{j} =
							\uparrow,\downarrow}T_{ij}\left\langle\Psi_{m}\right|\textbf{a}_{i,s_{i}}^{\dagger}\textbf{a}_{j,s_{j}}\left|\Psi_{n}\right\rangle
							\\ + \frac{1}{2}\sum_{i,j,k,l = 1}^{d}\sum_{s_{i},s_{j},s_{k},s_{l} =
							\uparrow,\downarrow}V_{ijkl}\left\langle\Psi_{m}\right|\textbf{a}_{i,s_{i}}^{\dagger}
							\textbf{a}_{j,s_{j}}^{\dagger}\textbf{a}_{k,s_{k}}
							\textbf{a}_{l,s_{l}}\left|\Psi_{n}\right\rangle,
							\label{eq:coup}
							\end{split}
							\end{equation}
						</div>

					</div>
				</div>
			</section>

			<section data-background-color="white">
				<h3>Singlet fission model for PDI trimer</h3>
				<div class="wrap">
					<div class="grid">
						<div class="column">
							<div class="bg-white shadow">
								<img width="70%" src="nsd/figure1_scheme_structure.png">
								<!-- <img width="50%" src="../newSD/thesis/pbi.png"> -->
							</div>
						</div>
						<div class="column" style="font-size:x-large;text-align: left; ">

							<p>A perylene diimide stack with three monomers (<i>m</i>, <i>n</i>, <i>o</i>) is
								considered.</p>

							<p>HOMO and LUMO of each monomer are included.</p>

							<p>Assuming singlet multiplicity, 19 diabatic states are constructed:</p>
							<ul>
								<li>1 ground state (GS)</li>
								<li>3 locally excited singlet states (LE)</li>
								<li>6 charge transfer states (CT)</li>
								<li>6 doubly excited mixed CT-triplet states</li>
								<li>3 correlated paired triplet states (<sup>1</sup>TT)</li>
							</ul>
						</div>
					</div>
				</div>
			</section>


			<section data-background-color="white">
				<h3>Example Wave Function </h3>
				<div class="wrap">
					<div class="grid vertical-align">
						<div class="column" style="font-size: x-large;">
							\begin{equation}
							| \text{S}_{1}\text{S}_{0}\text{S}_{0} \rangle = \substack{
							\displaystyle{ - \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\uparrow} }
							l_{m_{\downarrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\uparrow}}
							h_{o_{\downarrow}} h_{n_{\uparrow} } h_{n_{\downarrow}}} $}
							\displaystyle{ + \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\downarrow} }
							l_{m_{\uparrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\uparrow}} h_{o_{\downarrow}}
							h_{n_{\uparrow} } h_{n_{\downarrow}}} $}\\
							\displaystyle{ + \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\uparrow} }
							l_{m_{\downarrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\downarrow}}
							h_{o_{\uparrow}} h_{n_{\uparrow} } h_{n_{\downarrow}}} $}
							\displaystyle{ - \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\downarrow} }
							l_{m_{\uparrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\downarrow}} h_{o_{\uparrow}}
							h_{n_{\uparrow} } h_{n_{\downarrow}}} $}\\
							\displaystyle{ + \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\uparrow} }
							l_{m_{\downarrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\uparrow}}
							h_{o_{\downarrow}} h_{n_{\downarrow} } h_{n_{\uparrow}}} $}
							\displaystyle{ - \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\downarrow} }
							l_{m_{\uparrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\uparrow}} h_{o_{\downarrow}}
							h_{n_{\downarrow} } h_{n_{\uparrow}}} $}\\
							\displaystyle{ - \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\uparrow} }
							l_{m_{\downarrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\downarrow}}
							h_{o_{\uparrow}} h_{n_{\downarrow} } h_{n_{\uparrow}}} $}
							\displaystyle{ + \frac { 1 }{ \sqrt { 8}}} \colorbox{yellow}{$ h_{m_{\downarrow} }
							l_{m_{\uparrow} } $ } \colorbox{green}{$ \color{white}{ h_{o_{\downarrow}} h_{o_{\uparrow}}
							h_{n_{\downarrow} } h_{n_{\uparrow}}} $}
							}
							\label{eq:LE}
							\end{equation}
							

						</div>
						<div class="column">
							<div class="bg-white shadow" style="font-size: x-large;">
								\begin{equation}
								| \text{TS}_{0}\text{T} \rangle = \substack{
								\displaystyle{ - \frac { 1 }{ \sqrt { 6}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\uparrow}} h_{o_{\downarrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}
								\displaystyle{ - \frac { 1 }{ \sqrt { 6}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\downarrow}} h_{o_{\uparrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}\\
								\displaystyle{ + \frac { 1 }{ \sqrt { 6}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\uparrow}} h_{o_{\downarrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}
								\displaystyle{ + \frac { 1 }{ \sqrt { 6}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\downarrow}} h_{o_{\uparrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}\\
								\displaystyle{ + \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\downarrow}} h_{o_{\uparrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}
								\displaystyle{ + \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\uparrow}} h_{o_{\uparrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}\\
								\displaystyle{ + \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\downarrow}} h_{o_{\downarrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}
								\displaystyle{ + \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\uparrow}} h_{o_{\downarrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\uparrow}} h_{n_{\downarrow}}} $}\\
								\displaystyle{ - \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\downarrow}} h_{o_{\uparrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}
								\displaystyle{ - \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\uparrow}} h_{o_{\uparrow}} l_{o_{\downarrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}\\
								\displaystyle{ - \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\uparrow}}
								l_{m_{\downarrow}} h_{o_{\downarrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}
								\displaystyle{ - \frac { 1 }{ \sqrt { 24}} } \colorbox{yellow}{ $ h_{m_{\downarrow}}
								l_{m_{\uparrow}} h_{o_{\downarrow}} l_{o_{\uparrow}} $ } \colorbox{green}{ $
								\color{white}{ h_{n_{\downarrow}} h_{n_{\uparrow}}} $}
								}
								\label{eq:TST}
								\end{equation}
								
							</div>
						</div>
					</div>
				</div>
			</section>

			<section data-background-color="white">
				<h3>Couplings and Energies expressions</h3>
				<div class="wrap">
					<div class="grid">
						<div class="column" style="font-size: x-large;">
							
							\begin{equation}
							\langle \text{TS}_{0}\text{T} \vert \hat{\text{T}} \vert \text{TS}_{0}\text{T} \rangle =
							2\langle h_{n} | \hat{\text{h}} | h_{n} \rangle + \langle l_{m} | \hat{\text{h}} | l_{m}
							\rangle + \langle h_{m} | \hat{\text{h}} | h_{m} \rangle + \langle l_{o} | \hat{\text{h}} |
							l_{o} \rangle + \langle h_{o} | \hat{\text{h}} | h_{o} \rangle
							\label{eq:etst1}
							\end{equation}

							\begin{equation}
							\begin{split}
							\langle \text{TS}_{0}\text{T} \vert \hat{\text{G}} \vert \text{TS}_{0}\text{T} \rangle = &
							\colorbox{yellow}{$ + \frac{1}{2} (h_{m} h_{o} |h_{o} h_{m}) $ }
							\colorbox{yellow}{$ + \frac{1}{2} (h_{m} l_{o} |l_{o} h_{m}) $ }\\&
							\colorbox{yellow}{$ + \frac{1}{2} (h_{o} l_{m} |l_{m} h_{o}) $ }
							\colorbox{yellow}{$ + \frac{1}{2} (l_{m} l_{o} |l_{o} l_{m}) $ }\\&
							\colorbox{green}{$ \color{white}{+ (h_{m} h_{m} |h_{o} h_{o}) }$ }
							\colorbox{green}{$ \color{white}{+ (h_{m} h_{m} |l_{m} l_{m}) }$ }\\&
							\colorbox{green}{$ \color{white}{+ (h_{m} h_{m} |l_{o} l_{o}) }$ }
							\colorbox{green}{$ \color{white}{+ (h_{o} h_{o} |l_{m} l_{m}) }$ }\\&
							\colorbox{green}{$ \color{white}{+ (h_{o} h_{o} |l_{o} l_{o}) }$ }
							\colorbox{green}{$ \color{white}{+ (l_{m} l_{m} |l_{o} l_{o}) }$ }\\&
							\colorbox{orange}{$ + 2 (h_{n} h_{n} |h_{n} h_{n}) $ }
							\colorbox{orange}{$ + 2 (h_{m} h_{m} |h_{n} h_{n}) $ }
							\colorbox{orange}{$ + 2 (h_{o} h_{o} |h_{n} h_{n}) $ }\\&
							\colorbox{orange}{$ + 2 (h_{n} h_{n} |l_{m} l_{m}) $ }
							\colorbox{orange}{$ + 2 (h_{n} h_{n} |l_{o} l_{o}) $ }\\&
							\colorbox{pink}{$ - (h_{m} h_{n} |h_{n} h_{m}) $ }
							\colorbox{pink}{$ - (h_{m} l_{m} |l_{m} h_{m}) $ }\\&
							\colorbox{pink}{$ - (h_{o} h_{n} |h_{n} h_{o}) $ }
							\colorbox{pink}{$ - (h_{o} l_{o} |l_{o} h_{o}) $ }\\&
							\colorbox{pink}{$ - (h_{n} l_{m} |l_{m} h_{n}) $ }
							\colorbox{pink}{$ - (h_{n} l_{o} |l_{o} h_{n}) $ }
							\end{split}
							\label{eq:etst2}
							\end{equation}

							
						</div>

						<div class="column" style="font-size: x-large;">

							<!-- \begin{equation}
							\langle \text{ACT} | \hat{\text{T}} | \text{TS}_{0}\text{T} \rangle = - \langle h_{n} |
							\hat{\text{h}} | h_{m} \rangle
							\label{eq:ACT_TST_1}
							\end{equation}
							\begin{equation}
							\begin{split}
							\langle \text{ACT} | \hat{\text{G}} | \text{TS}_{0}\text{T} \rangle = &
							\colorbox{yellow} {$ +\frac{3}{2} (h_{n} h_{o} | h_{o} h_{m} )$ }
							\colorbox{yellow} {$ +\frac{3}{2} (h_{n} l_{o} | l_{o} h_{m} )$ }\\&
							\colorbox{green} {$ - (h_{m} h_{m} | h_{n} h_{m} )$ }
							\colorbox{green} {$ - (h_{n} h_{m} | h_{n} h_{n} )$ }\\&
							\colorbox{green} {$ - (h_{n} h_{m} | h_{o} h_{o} )$ }
							\colorbox{green} {$ - (h_{n} h_{m} | l_{m} l_{m} )$ }
							\colorbox{green} {$ - (h_{n} h_{m} | l_{o} l_{o} )$ }
							\end{split}
							\label{eq:ACT_TST_2}
							\end{equation}
							\hline -->
							\begin{equation}
							\langle \text{CAT} | \hat{\text{T}} | \text{S}_{0}\text{TT} \rangle = - \langle h_{m} |
							\hat{\text{h}} | h_{n} \rangle
							\label{eq:CAT_STT_1}
							\end{equation}
							\begin{equation}
							\begin{split}
							\langle \text{CAT} | \hat{\text{G}} | \text{S}_{0}\text{TT} \rangle = &
							\colorbox{yellow} { $ \frac{3}{2} (h_{m} h_{o} | h_{o} h_{n}) $}
							\colorbox{yellow} { $ +\frac{3}{2} (h_{m} l_{o} | l_{o} h_{n}) $}\\&
							\colorbox{green} {$ \color{white}{- (h_{m} h_{m} | h_{m} h_{n}) }$ }
							\colorbox{green} {$ \color{white}{- (h_{m} h_{n} | h_{n} h_{n}) }$ }\\&
							\colorbox{green} {$ \color{white}{- (h_{m} h_{n} | h_{o} h_{o}) }$ }
							\colorbox{green} {$ \color{white}{- (h_{m} h_{n} | l_{n} l_{n}) }$ }
							\colorbox{green} {$ \color{white}{- (h_{m} h_{n} | l_{o} l_{o}) }$ }
							\end{split}
							\label{eq:CAT_STT_2}
							\end{equation}
							<!-- In the transfer of states $\langle \text{ACT} | \hat{\text{H}} | \text{S}_{0}\text{TT}
							\rangle$ and $\langle \text{CAT} | \hat{\text{H}} | \text{TS}_{0}\text{T} \rangle$,
							electrons move from the LUMO of fragment $m$ to the LUMO of fragment $n$. Similar to
							previous expressions they have both one-electron integral terms (as shown in equations
							\ref{eq:ACT_STT_1} and \ref{eq:CAT_TST_1}) and ERI terms (as shown in equations
							\ref{eq:ACT_STT_2} and \ref{eq:CAT_TST_2}). The different ERI terms are $2 (l_{m} l_{n} |$ $
							h_{m} h_{m})$ in $\langle \text{ACT} | \hat{\text{H}} | \text{S}_{0}\text{TT} \rangle$ and
							$2 (l_{m} l_{n} | h_{n} h_{m})$ in $\langle \text{CAT} | \hat{\text{H}} |
							\text{TS}_{0}\text{T} \rangle$.

							In equations \ref{eq:ACT_STT_2} and \ref{eq:CAT_TST_2}, the ERIs shown with a yellow
							background represent exchange integrals with a coefficient of $\frac{1}{2}$ and have
							orbitals of the stationary triplet fragment, i.e., $h_{o}$ and $l_{o}$. Those with a green
							background represent Coulomb integrals. The ERI terms with an orange background are Coulomb
							integrals involving the doubly occupied orbitals and have a coefficient of 2, while the ERI
							terms in pink are exchange integrals involving the fragments participating in the
							transition.
							\begin{equation}
							\langle \text{ACT} | \hat{\text{T}} | \text{S}_{0}\text{TT} \rangle = \langle l_{m} |
							\hat{\text{h}} | l_{n} \rangle
							\label{eq:ACT_STT_1}
							\end{equation}
							\begin{equation}
							\begin{split}
							\langle \text{ACT} | \hat{\text{G}} | \text{S}_{0}\text{TT} \rangle = &
							\colorbox{orange} {$ + 2 (l_{n} l_{m} | h_{m} h_{m} ) $ }\\&
							\colorbox{yellow} {$ + \frac{1}{2} ( l_{n} h_{o} | h_{o} l_{m} ) $}
							\colorbox{yellow} {$ + \frac{1}{2} ( l_{n} l_{o} | l_{o} l_{m} ) $}\\&
							\colorbox{pink} { $ - (l_{n} h_{m} | h_{m} l_{m} ) $}
							\colorbox{pink} { $ - (l_{n} h_{n} | h_{n} l_{m} ) $}\\&
							\colorbox{green} {$ + (l_{n} l_{m} | h_{n} h_{n} ) $}
							\colorbox{green} {$ + (l_{n} l_{m} | h_{o} h_{o} ) $}
							\colorbox{green} {$ + (l_{n} l_{m} | l_{o} l_{o} ) $}\\&
							\end{split}
							\label{eq:ACT_STT_2}
							\end{equation}

							\hline -->
							\begin{equation}
							\langle \text{CAT} | \hat{\text{T}} | \text{TS}_{0}\text{T} \rangle = \langle l_{n} |
							\hat{\text{h}} | l_{m} \rangle
							\label{eq:CAT_TST_1}
							\end{equation}
							\begin{equation}
							\begin{split}
							\langle \text{CAT} | \hat{\text{G}} | \text{TS}_{0}\text{T} \rangle =&
							\colorbox{orange} { $ +2 (l_{m} l_{n} | h_{n} h_{n} ) $ }\\&
							\colorbox{yellow} { $ + \frac{1}{2} (l_{m} h_{o} | h_{o} l_{n} ) $ }
							\colorbox{yellow} { $ + \frac{1}{2} (l_{m} l_{o} | l_{o} l_{n} ) $ }\\&
							\colorbox{pink} { $ -(l_{m} h_{m} | h_{m} l_{n}) $ }
							\colorbox{pink} { $ -(l_{m} h_{n} | h_{n} l_{n}) $ }\\&
							\colorbox{green} { $ \color{white}{+ (l_{m} l_{n} | h_{m} h_{m} ) } $ }
							\colorbox{green} { $ \color{white}{+ (l_{m} l_{n} | h_{o} h_{o} ) } $ }
							\colorbox{green} { $ \color{white}{+ (l_{m} l_{n} | l_{o} l_{o} ) } $ }
							\end{split}
							\label{eq:CAT_TST_2}
							\end{equation}


						</div>

					</div>
			</section>
			<section data-background-color="white">
				<h3> incorporation of Core orbital Interaction</h3>
				<div class="wrap">
					<div class="grid vertical-align">
						<div class="column" style="font-size: x-large;">
							<p>
								To
								incorporate
								the electron repulsion integrals (ERI) contribution of core electrons the electron
								repulsion
								interaction
								term (\(\text{G}_{core}\)) is determined by summing over specific core orbital
								indices
								in
								the
								expression involving the core density operator.

								The core density operator for the core
								orbitals is defined as:

								\begin{equation}
								\mathbf{\hat{D}}_{core} = 2 \mathbf{C}_{core} \mathbf{C}^{\dagger}_{core},
								\label{eq:D_core}
								\end{equation}


								Thus,
								\begin{equation}
								\text{G}_{core} = \sum_{r,s } \mathbf{\hat{D}}_{core} [(pq|rs) - \frac{1}{2}(pr|sq)]
								\label{eq:V_core}
								\end{equation}


								The effective one-electron operator for active orbitals.



								\begin{equation}
								\hat{h}_{act} = \hat{h}^{AO} + \text{G}_{core}.
								\label{eq:h_act}
								\end{equation}



								\begin{equation}
								\langle \psi_{a} \vert \hat{h}^{MO} \vert \psi_{b} \rangle= \textbf{C}_{a}^{\dagger}
								\hat{h}_{\text{act}} \textbf{C}_{b} \label{eq:OneI}
								\end{equation}

								The ERI in
								the
								molecular orbital basis are calculated by transforming their counterparts in the
								atomic
								orbital (AO) basis:

								\begin{equation}
								( \psi_{a} \psi_{b} \vert \psi_{c} \psi_{d} ) =
								\sum_{p}\sum_{q}\sum_{r}\sum_{s}C^{a}_{p}C^{b}_{q}C^{c}_{r}C^{d}_{s} (pq \vert rs)
								\label{eq:twoI}
								\end{equation}
							</p>
						</div>
						<div class="column">
							<div class="bg-white shadow">
								<img src="nsd/oeb.png">
							</div>
						</div>
					</div>
				</div>
			</section>
			<section data-background-color="white">
				<h3>Semi-Empirical AM1 Approximations</h3>
				<div class="wrap">
					<div class="grid">

						<div class="column" style="text-align: left; font-size: x-large;">
							<p>
								<!-- The Python package <b>PySEQM</b> was used to calculate matrix elements for the
								transitions.-->
								The implementation of \( T_{LE \rightarrow ^{1}TT} \) neglects additional
								two-electron
								contributions, and the
								following approximation was used:
							</p>

							<p>
								\[
								^{Fock}T_{RP} = \sqrt{\frac{3}{2}}\left\vert \frac{( l_{A} | \mathbf{\hat{F}} |
								l_{B} )
								( l_{A} |
								\mathbf{\hat{F}} | h_{B} )}{\Delta E(\text{CA})}
								- \frac{( h_{A} | \mathbf{\hat{F}} | h_{B} ) ( h_{A} | \mathbf{\hat{F}} | l_{B} )
								}{\Delta E(\text{AC})} \right\vert.
								\]
							</p>
							<p>
								Then approximated by transitioning from Fock matrix elements to overlap matrix
								elements,
								represented as \(\langle \phi |\mathbf{\hat{F}}| \psi \rangle = \epsilon \langle
								\phi|
								\psi
								\rangle\), where \(\epsilon \) is constant. The obtained equation is:

								\begin{equation}
								^{Overlap}T_{RP} = \sqrt{\frac{3}{2}}\left \vert\frac{\langle l_{A} | l_{B} \rangle
								\langle l_{A} | h_{B}
								\rangle}{\Delta E(\text{CA})} - \frac{\langle h_{A} | h_{B} \rangle \langle h_{A} |
								l_{B}
								\rangle }{\Delta E(\text{AC})}\right \vert.
								\end{equation}
							</p>
							<p>
								Additionally, \(\Delta E(\text{CA})\) and \(\Delta E(\text{AC})\) are approximated
								as
								one for simplicity.
							</p>
							\begin{equation}
							T_{RP} = \left \vert \langle l_{A} | l_{B} \rangle \langle l_{A} | h_{B} \rangle -
							\langle
							h_{A} | h_{B} \rangle \langle h_{A} | l_{B} \rangle \right \vert.

							\end{equation}



						</div>

						<div class="column" style="text-align: left; font-size: x-large;">
							<p><img style="width: 40%;" src="nsd/PBI_GEOM.png">
								<img style="width: 40%;" src="nsd/PBI_GEOM2.png">
							</p>
							<p>
								Cofacially stacked perylene diimide (PDI) dimer molecules were analyzed.
							</p>
							<p>
								The monomer geometry was optimized using the CAM-B3LYP functional, with an
								interplanar
								distance of \( \Delta Z = 3.41 \, \AA \).
							</p>
							<p>The scan was conducted across spatial displacements \( \Delta X \): 0 to 4 \(\AA\),
								\(
								\Delta Y \): 0 to 4 \(\AA\), with a step size of 0.1 \(\AA\).</p>

						</div>
					</div>
				</div>
			</section>
			<section data-background-color="white">
				<h3>Semi-Empirical AM1 Approximations</h3>
				<div class="wrap">
					<div class="grid">
						<div class="column" style="text-align: left; font-size: x-large;">


							<img style="width: 70%;" src="nsd/PBI_diabatic.png"
								alt="PBI Diabatic Coupling">

							<img style="width: 55%; left: 200em;" src="overlap-validation.png">

						</div>
						<div class="column" style="text-align: left; font-size: x-large;">
							<h4>Benchmarking With Active Space Decomposition (ASD) </h4>
							<img style="width: 80%;" src="nsd/PBI_ASD.png">
							<li>An ASD scan was performed using the RAS-CI/cc-pVDZ,
								employing a RAS(11,4,11)[1,1] configuration.</li>

							<li>The ASD scan results are consistent with earlier studies by Mirjani et al. and
								Renaud et
								al.\(^{1,2}\)</li>
							<li>Resemblance of Semi-Empirical scan to the ab-initio plot is excellent.
							</li>
						</div>
					</div>
				</div>
				<div class="footer">[1] F. Mirjani et al., The Journal of Physical Chemistry C 118, 14192 (2014).
					[2] N. Renaud, P. A. Sherratt, and M. A. Ratner, The Journal of Physical Chemistry Letters 4,
					1065
					(2013).

				</div>

			</section>
			<section data-background-color="white">
				<div class="wrap">
					<div class="grid ">

						<div class="column">
							<div class="bg-white shadow" style="font-size: x-large; text-align: left;">
								<h3> Non-Adiabatic Couplings</h3>
								<!-- <p> Loss of energy of exciton due to vibration is big problem in organic material</p> -->
								<!-- <p> Non-Adiabatic Couplings offer insights in such process</p> -->
								<p>
									By diagonalizing the diabatic Hamiltonian, the adiabatic states, denoted as \(
									|S^* \rangle \) and \( |TT^*\rangle \), are obtained.
									<!-- singlet exciton states are closely aligned with: -->
								</p>
								<!-- <ul> \( S^{Bright} = \frac{1}{\sqrt{2}} (|S_1 S_0\rangle + |S_0 S_1\rangle )
									\) and \( S^{Dark} = \frac{1}{\sqrt{2}} (|S_1 S_0\rangle - |S_0 S_1\rangle )
									\).</li>
								</ul> -->
								<p>
									The singlet-fission rate is approximately proportional to the square of the
									first-order derivative coupling vector's magnitude.
									<!-- The scalar product in Equation
									can be computed efficiently using automatic
									differentiation and PYSEQM. -->
								</p>
								\[
								\vec{\tau} = \langle S^* | \nabla | TT^*\rangle = \sum_{i=S_0S_1,S_1S_0,\ldots,TT}
								C^{\text{exciton}}_i \nabla C_i^{\text{triplet}}
								\]

								\[
								\vert T_{RP} \vert^2_{\text{NAC}} = \frac{1}{2} \vert \langle
								{S^{\text{bright*}}} | \nabla | {TT^*} \rangle\vert^2 + \vert \langle
								{S^{\text{dark*}}} | \nabla | {TT^*} \rangle \vert^2
								\]
								<img style="width: 60%;" src="../nsd/PBI_non-adiabatic.png">
								<p>
									Shared features with scan of norm of non adiabatic coupling vector from Farag
									and
									Krylov
								</p>
							</div>
						</div>
						<div class="column" style="font-size: x-large;text-align: left;">
							<ul>
								<li>Used PySEQM for semi-empirical calculations.</li>
								<li>PySEQM utilizes a PyTorch backend.</li>
								<li>Automatic differentiation is employed for efficient gradient calculations.</li>
							</ul>
							<h4> Autograd</h4>
							<ul>
								<img style="width: 40%;" src="nsd/Autograd.png">
								<li>Forward Mode:
									<ul>
										<li>Evaluates the computational graph during forward propagation.</li>
										<li>Tracks operations and inputs for each variable.</li>
									</ul>
								</li>
								<li>Backward Mode:
									<ul>
										<li>Traverses the computational graph in reverse order during
											backpropagation.
										</li>
										<li>Applies the <span class="highlight">chain rule</span> to compute
											gradients
											efficiently.</li>
									</ul>
								</li>
							</ul>


						</div>

					</div>
				</div>
				<div class="footer">[1] M. H. Farag and A. I. Krylov, The Journal of Physical Chemistry C 122, 25753
					(2018).</div>
			</section>
			<section data-background-color="white">
				<h3>Functionality optimisation</h3>
				<div class="wrap">
					<div class="grid vertical-align">
						<div class="column" style="font-size: x-large;">
							<ul>
								<li>
									<p>The diabatic coupling \( T_{RP} \) is defined as:
										\( T_{RP} = \left \vert \langle l_{A} | l_{B} \rangle \langle l_{A} | h_{B}
										\rangle
										- \langle h_{A} | h_{B} \rangle \langle h_{A} | l_{B} \rangle \right \vert.
										\)
									</p>
								</li>
								<li>
									<p><strong>Functionality optimization</strong> using a custom objective
										function \( L(x) \).</p>
								</li>
								<li>
									<p>The gradients for \( L(x) \) are computed automatically using an
										<strong>algorithmic differentiation framework</strong>, enabling efficient
										optimization.
									</p>
								</li>
								<li>
									<p>The optimization minimizes the objective function \( L(x) \), which is
										expressed
										as:

										\( L(x) = E(x) - \omega \cdot \log(|T_{RP}|^2(x)). \)</p>
								</li>
								<li>
									<p>The ground state energy component \( E(x) \) ensures that the molecular
										conformation
										is physically plausible</p>
								</li>
							</ul>

						</div>
						<div class="column">
							<div class="bg-white shadow">

								<img src="nsd/ConT_PBI.png">
							</div>
						</div>
					</div>
				</div>
			</section>
			<section data-background-color="white">
				<h2>Functionality optimisation</h2>
				<p>By Johannes E Greiner and Anurag Singh</p>
				<div class="wrap">
					<div class="grid ">
						<div class="column" style="font-size: x-large;">
							<ul>
								<li>Searched for PBI dimer structures with high effective singlet fission
									coupling:
									<ul>
										<li>500 optimizations conducted, followed by PCA
											to analyze resulting dimer structures.</li>
										<li>Results grouped into 4 clusters based on structural characteristics:
										</li>
										<ul>
											<li><strong>Cluster 2:</strong>
												<ul>
													<li>Highest mean effective SF coupling.</li>
													<li>Monomers have twist, stacking motif with
														translation in both the \( x \)- and \( y \)-directions, and
														rotation along the \( z \)-axis.</li>
												</ul>
											</li>
											<li><strong>Cluster 3:</strong>
												<ul>
													<li>Exhibits curvature and strong translation along the \( x
														\)-axis.</li>
												</ul>
											</li>
											<li><strong>Clusters 1 and 4:</strong>
												<ul>
													<li>Nearly planar structures.</li>
													<li>Show rotation around the \( z \)-axis and relative
														translations
														of monomers in the \( x \)- and \( y \)-directions.</li>
												</ul>
											</li>
										</ul>
									</ul>
								</li>
							</ul>
							<div style="display: flex; justify-content: space-between;">
								<table style="width: 45%; border-collapse: collapse; margin-right: 10px;">
									<thead>
										<tr>
											<th style="border: 1px solid black; padding: 8px;">Name</th>
											<th style="border: 1px solid black; padding: 8px;">\(2 E_{T_{1}} -
												E_{S_{1}}\) in eV</th>
										</tr>
									</thead>
									<tbody>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C1\(_A\)</td>
											<td style="border: 1px solid black; padding: 8px;">-0.0682</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C1\(_B\)</td>
											<td style="border: 1px solid black; padding: 8px;">-0.0663</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C2\(_A\)</td>
											<td style="border: 1px solid black; padding: 8px;">-0.0795</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C2\(_B\)</td>
											<td style="border: 1px solid black; padding: 8px;">-0.0714</td>
										</tr>
									</tbody>
								</table>

								<table style="width: 45%; border-collapse: collapse;">
									<thead>
										<tr>
											<th style="border: 1px solid black; padding: 8px;">Name</th>
											<th style="border: 1px solid black; padding: 8px;">\(2 E_{T_{1}} -
												E_{S_{1}}\) in eV</th>
										</tr>
									</thead>
									<tbody>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C3\(_A\)</td>
											<td style="border: 1px solid black; padding: 8px;">0.2993</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C3\(_B\)</td>
											<td style="border: 1px solid black; padding: 8px;">0.3002</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C4\(_A\)</td>
											<td style="border: 1px solid black; padding: 8px;">-0.0676</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-C4\(_B\)</td>
											<td style="border: 1px solid black; padding: 8px;">0.2905</td>
										</tr>
										<tr>
											<td style="border: 1px solid black; padding: 8px;">PBI-Planar</td>
											<td style="border: 1px solid black; padding: 8px;">0.3154</td>
										</tr>
									</tbody>
								</table>
							</div>


						</div>
						<div class="column">
							<div class="bg-white shadow" style="font-size: large;">
								<img src="PCA3.png" style="width:100%">
								<img src="PCA.png">
								<img src="PCA2.png">
							</div>

						</div>
					</div>
				</div>

			</section>
			<section data-background-color="white" data-background-image="AllPics.png" data-background-opacity="0.2">
				<h3 style="top: -1em;position: absolute;text-align: center;width: 100%;">Singlet Fission Study in B-N substituted perylene </h3>
				<p style="font-size:large">By Anurag Singh and Alexander Humeniuk</p>
				<div class="wrap">
					<div class="grid">
						<div class="column">

							<div class="content" style="font-size: x-large;">

								<p>The study aimed to increase the singlet fission rate through doping.</p>

								<ol>
									<li>
										<strong>Substitution Strategy:</strong>
										<ul>
											<li>All possible substitutions were enumerated where two adjacent carbon
												atoms were replaced by boron-nitrogen (B-N).</li>
											<li>The resulting molecules were labeled as
												<em>perylene-(BN)<sub>n</sub>-<i>i</i></em>, with:
												<ul>
													<li>\( n \): The number of B-N substitutions.</li>
													<li>\( i = 0, 1, 2, \ldots \): Enumeration of structural
														isomers.
													</li>
												</ul>
											</li>
										</ul>
									</li>
									<li>
										<strong>Generated Molecules:</strong>
										<ul>
											<li>\((BN)_1\)-substitution resulted in 13 unique molecules.</li>
											<li>\((BN)_2\)-substitution resulted in 256 unique molecules.</li>
										</ul>
									</li>

								</ol>
							</div>

						</div>
						<div class="column" style="font-size: x-large;">
							<div class="bg-white shadow">
								<li>
									<strong>Property Calculations:</strong>
									<ul>
										<li>Vertical singlet and triplet excitation energies were computed at the
											CASPT2 and TD-DFT levels of theory.</li>
									</ul>
								</li>


								<img style="width: 70%;"
									src="nsd/singlet_vs_triplet_by_resonance_group.png">
								<img style="width: 70%;"
									src="nsd/singlet_vs_triplet_by_resonance_group_caspt2.png">

							</div>
						</div>
						<div class="column" style="font-size: x-large;">
							<div class="bg-white shadow">
								<li>
									<strong>Methodology:</strong>
									<ul>
										<li>Searched slipped stacking geometries of molecular dimers to
											achieve higher SF rates.</li>
										<ul>
											<li>Diabatic method.</li>
											<li>Non-Adiabatic Coupling (NAC) method.</li>
										</ul>
								</li>

								</ul>
								</li>
								<div class="bg-white shadow">
									<!-- <img style="width: 65%;"
										src="../newSD/thesis/Figures/local_maxima_of_sf_rate_fock.png">
									<img style="width: 65%;"
										src="../newSD/thesis/Figures/local_maxima_of_sf_rate_non-adiabatic.png"> -->


									<img style="width: 65%;"
										src="nsd/local_maxima_of_sf_rate_fock.png">
									<img style="width: 65%;"
										src="nsd/local_maxima_of_sf_rate_non-adiabatic.png">
								</div>
							</div>
						</div>
					</div>
				</div>
			</section>
			<section data-background-color="white">
				<h3>Best Isomer</h3>
				<div class="wrap">
					<div class="grid ">
						<div class="column" style="font-size: x-large;">
							<ul>
								<li>
									<strong>\(S_1\) excitation energy range:</strong>
									\( 1.8~\text{eV} \leq E(S_1, \text{CASPT2}) \leq 3.0~\text{eV} \).
									<p>This ensures the molecule absorbs in then region where the solar
										spectrum
										has
										high intensity.</p>
								</li>
								<li>
									<strong>\(T_1\) state energy constraint:</strong>
									<p>\( 0.8~\text{eV} < E(T_1, \text{TD-DFT}) \) To ensure solar cell operation with a
											singlet fission layer.</p>
								</li>
								<!-- The energy of the \(T_1\) state,
												which limits the maximum voltage of a solar cell operating with a singlet
												fission layer, should satisfy .</p> </li> -->
								<li>
									<strong>Condition for singlet fission energetics:</strong>
									<p>Singlet fission must be exoergic or at most slightly endoergic.
										\( -0.3~\text{eV} < \Delta E_{ST}(\text{CASPT2}), \Delta E_{ST}(\text{TD-DFT}) <
											0.2~\text{eV} \) pass this test.</p>
								</li>
								<li>
									<strong>\(T_2\) state constraint:</strong>
									<p></p>The \(T_2 > S_1\) state to exclude intersystem crossing as a
									competing loss channel with singlet fission.
									The requirement is \( \Delta E_{TT}(\text{CASPT2}), \Delta E_{TT}(\text{TD-DFT})
									< -0.2~\text{eV} \).<p>
								</li>
							</ul>


						</div>
						<div class="column">
							<div class="bg-white shadow" style="font-size: x-large;">
								<ul>
									<li>Only one candidate, BN2-112, remains.</li>
									<li>BN2-112 has desirable properties, including:
										<ul>
											<li>A Lewis structure without formal charges.</li>
											<li>Moderate biradical character of \( y_0 = 0.06 \), compared to a
												range of \( y_0 = 0.01 \) to \( 0.66 \) for the full set of isomers.
											</li>
											<li>An oscillator strength \( f(S_0 \to S_1) = 0.27 \), which is close
												to undoped perylene (\( 0.30 \)).</li>
										</ul>
									</li>
								</ul>

								<!-- <img style="width: 45%;" src="../newSD/thesis/Figures/selected_isomers.png">
								<img style="width: 45%;"
									src="../newSD/thesis/Figures/representative_lewis_structures.png"> -->

									<img style="width: 45%;" src="nsd/selected_isomers.png">
								<img style="width: 45%;"
									src="nsd/representative_lewis_structures.png">

							</div>
						</div>
					</div>
				</div>
			</section>


		</div>
	</div>

	<script src="https://unpkg.com/reveal.js@5.1.0/dist/reveal.js"></script>
	<script src="https://unpkg.com/reveal.js@5.1.0/plugin/notes/notes.js"></script>
	<script src="https://unpkg.com/reveal.js@5.1.0/plugin/markdown/markdown.js"></script>
	<script src="https://unpkg.com/reveal.js@5.1.0/plugin/highlight/highlight.js"></script>
	<script src="as1.js"></script>

	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,
			width: 1920,
			height: 720,
			scale: 0.5,
			slideNumber: false,
			autoSlide: 5000,
			loop: true,
preloadIframes: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import Stats from 'three/addons/libs/stats.module.js';
		import { EXRExporter } from 'three/addons/exporters/EXRExporter.js';
		import { FontLoader } from 'three/addons/loaders/FontLoader.js';
		import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
		import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

		let camera, scene, renderer, stats, textm, textn, texto;
		let cube, sphere, torus, material, bulbLight, bulbMat, hemiLight;
		let cubeCamera, cubeRenderTarget;
		let controls;
		let nelectron = 6;
		let mpath = 0, maxpath = 0, maxmpath = 0, finalM = 0;
		let mmpath = 0, finalS = 0;
		let waveFunction = "";
		const mv = document.getElementById("root");
		const div = document.createElement('div');
		console.log(mv);
		//const iframe = document.createElement('iframe');
		let render2;
		let can;
		let nn = 0

		init();
		init2();

		let renderTarget;
		let download = 0;

		function init() {


			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			// render2 = new CSS3DRenderer();
			can = document.getElementById("myCanvasId");
			console.log(can)
			console.log(can.className)
			//renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setPixelRatio(1);

			// renderer.setSize(can.parentElement.clientWidth, can.parentElement.clientHeight);
			//renderer.setSize(1024, 1024);
			//renderer.setSize(720, 720);
			renderer.setSize(720, 720);

			//renderer.setSize(can.parentElement.clientWidth, window.innerHeight/2);
			renderer.setAnimationLoop(animation);
			renderer.outputEncoding = THREE.sRGBEncoding;
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			// renderer.domElement.style.position = "absolute";
			//renderer.setClearColor(0xeeeeee, 1);
			renderer.setClearColor(0xffffff, 1);
			let child1 = document.getElementById("igc1");
			console.log(child1);
			//can.insertBefore(renderer.domElement, null);
			can.appendChild(renderer.domElement);


			//console.log(iframe);
			//iframe.style.width = '480px';
			//iframe.style.height = '360px';
			//iframe.style.border = '0px';
			//iframe.src = [ "m1.html" ].join( '' );
			//div.appendChild( iframe );

			// renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			// render2 = new CSS3DRenderer();
			// render2.setSize(window.innerWidth, window.innerHeight);
			// renderer.setPixelRatio(window.devicePixelRatio);
			// renderer.setSize(window.innerWidth, window.innerHeight);
			// const h = 2000;
			// const w = 2000;
			//renderer.setSize(w , h ); 
			// render2.setSize(w, h);
			// renderer.setAnimationLoop(animation);
			// renderer.outputEncoding = THREE.sRGBEncoding;
			// renderer.toneMapping = THREE.ACESFilmicToneMapping;
			// renderer.setClearColor(0x000000, 0);
			// document.body.appendChild(renderer.domElement);
			// window.addEventListener('resize', onWindowResized);
		}

		function init2() {

			camera = new THREE.PerspectiveCamera(45, 1, 1, 1000);
			//camera = new THREE.PerspectiveCamera( 30, 1, 1, 1000 );
			console.log("IG*C");
			console.log(can.parentElement.clientWidth);
			camera.position.z = 20 + (nelectron * 20) / 2;
			camera.position.y = 0;
			//camera.position.x = 10;
			//camera.rotation.x = Math.PI/2
			scene = new THREE.Scene();
			//scene.rotation.y = 0.1; // avoid flying objects occluding the sun
			scene.rotation.x = Math.PI / 8;
			scene.rotation.y = -Math.PI / 6;
			scene.position.x = - (nelectron * 10) / 5;
			scene.position.y = - (nelectron * 5) / 5;

			const bulbGeometry = new THREE.SphereGeometry(0.1, 10, 8);
			bulbLight = new THREE.PointLight(0x00ee88, 400, 1000, 1);
			bulbMat = new THREE.MeshStandardMaterial({
				emissive: 0xffffee,
				emissiveIntensity: 1000,
				color: 0xffffff
			});
			bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
			bulbLight.position.set(100, 10, 10);
			bulbLight.castShadow = true;
			scene.add(bulbLight);

			hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 1);
			scene.add(hemiLight);
			bulbLight = new THREE.PointLight(0xff0000, 400, 500, 2);
			bulbMat = new THREE.MeshStandardMaterial({
				emissive: 0xffffee,
				emissiveIntensity: 100,
				color: 0x000000
			});
			bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
			bulbLight.position.set(-100, 100, 10);
			bulbLight.castShadow = true;
			scene.add(bulbLight);

			bulbLight = new THREE.PointLight(0xff0000, 400, 500, 2);
			bulbMat = new THREE.MeshStandardMaterial({
				emissive: 0xffffee,
				emissiveIntensity: 100,
				color: 0x000000
			});
			bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
			bulbLight.position.set(100, 100, 0);
			bulbLight.castShadow = true;
			scene.add(bulbLight);

			bulbLight = new THREE.PointLight(0xfff0f0, 400, 1000, 2);
			bulbMat = new THREE.MeshStandardMaterial({
				emissive: 0xffffee,
				emissiveIntensity: 100,
				color: 0x000000
			});
			bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
			bulbLight.position.set(0, 100, 100);
			bulbLight.castShadow = true;
			scene.add(bulbLight);

			hemiLight = new THREE.HemisphereLight(0xddeeff, 0x0f0e0d, 0.1);
			scene.add(hemiLight);

			cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
			cubeRenderTarget.texture.type = THREE.HalfFloatType;
			cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);

			material = new THREE.MeshStandardMaterial({
				envMap: cubeRenderTarget.texture,
				roughness: 0.05,
				metalness: 1
			});




			//const gui = new GUI();

			//gui.add( material, 'roughness', 0, 1 );

			//gui.add( material, 'metalness', 0, 1 );

			//gui.add( renderer, 'toneMappingExposure', 0, 2 ).name( 'exposure' );




			//sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 15, 8 ), material );

			//scene.add( sphere );




			const material2 = new THREE.MeshStandardMaterial({
				roughness: 0.1,
				metalness: 0
			});

			const matLite = new THREE.MeshBasicMaterial({
				color: 0x005555,
				transparent: true,
				opacity: 0.9,
				side: THREE.DoubleSide
			});
			console.log(scene.children.length);
			firl(nelectron, finalS);
			controls = new OrbitControls(camera, renderer.domElement);
			controls.autoRotate = false;
		}




		function firl(nelectron, finalS) {
			const name = "sphere.json"
			fetch(name).then(response => {
				if (!response.ok) {
					throw new Error(response.statusText);
				}
				return response.json();
			}).then(data => {
				//console.log(data);
				const material2 = new THREE.MeshStandardMaterial({
					roughness: 0.1,
					metalness: 0
				});
				const material3 = new THREE.MeshStandardMaterial({
					roughness: 0.1,
					color: 0x00ff00,
					metalness: 0
				});

				const pt = GenerateSTree(nelectron)
				console.log(pt)
				const indx = GenerateConnection(pt)
				//console.log(pt)
				const st = []
				const ConPoints = []
				const ConCol = []
				for (let i = 0; i < pt[0].length; i++) {
					for (let j = 0; j < pt[0][i].length; j++) {
						sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 8), material2);
						sphere.position.x = i * 5;
						sphere.position.y = pt[0][i][j] * 5 - 10;
						sphere.position.z = -5;
						ConPoints.push(i * 5);
						ConPoints.push(pt[0][i][j] * 5 - 10);
						ConPoints.push(-5);
						ConCol.push(0);
						ConCol.push(0);
						ConCol.push(0);
						scene.add(sphere);
					}
					st.push(-1)
				}

				const mad = []
				pt[1][pt[1].length - 1][finalS].tracePrev(st, mad)
				console.log("s pathway")
				console.log(mad)
				const LinePoint = [];
				const LineCol = [];
				const indx2 = [];
				for (let i = 0; i < mad.length; i++) {
					for (let j = 0; j < mad[i].length; j++) {
						LinePoint.push(j * 5);
						LinePoint.push(mad[i][j] * 5 - 10);
						LinePoint.push(-i - 10);
						if (i == mpath) {
							LineCol.push(0.2);
							LineCol.push(1);
							LineCol.push(1);
						} else {
							LineCol.push(0);
							LineCol.push(0);
							LineCol.push(0);
						}
						if (j > 0) {
							indx2.push((i * mad[i].length) + j - 1);
							indx2.push((i * mad[i].length) + j);
						}
					}

				}
				maxpath = mad.length;
				const mlPoint = make_m(mad[mpath]);
				const mulPoint = mlPoint[0];
				const mul3d = []
				const mul3dxyz = []
				const mul3dCol = []
				const mRefxyz = []
				const mRefCol = []
				const mRefInx = []
				let mrefi = 0
				makeMconnection(mlPoint[1])
				const mad2 = []
				//console.log("irje");
				//console.log(mlPoint[1]);
				mlPoint[1][mlPoint[1].length - 1][finalM].tracePrev(st, mad2);
				console.log("M pathways")
				console.log(mad2)
				for (let i = 0; i < mulPoint.length; i++) {
					for (let j = 0; j < mulPoint[i].length; j++) {
						sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 8), material2);
						sphere.position.x = i * 5;
						sphere.position.y = mad[mpath][i] * 5 - 10;
						sphere.position.z = mulPoint[i][j] * 5 + 20;
						mul3d.push(i * 5);
						mul3d.push(mad[mpath][i] * 5 - 10);
						mul3d.push(mulPoint[i][j] * 5 + 20);
						mul3dxyz.push([i, mad[mpath][i], mulPoint[i][j]])
						mul3dCol.push(0);
						mul3dCol.push(0);
						mul3dCol.push(0);
						mRefxyz.push(i * 5);
						mRefxyz.push(mad[mpath][i] * 5 - 10);
						mRefxyz.push(mulPoint[i][j] * 5 + 20);
						mRefxyz.push(i * 5);
						mRefxyz.push(-10);
						mRefxyz.push(mulPoint[i][j] * 5 + 20);
						mRefCol.push(0.2);
						mRefCol.push(0.8);
						mRefCol.push(0.8);
						mRefCol.push(0.2);
						mRefCol.push(0.8);
						mRefCol.push(0.8);
						mRefInx.push(mrefi);
						mrefi++;
						mRefInx.push(mrefi);
						mrefi++;
						scene.add(sphere);
					}

				}

				const pathI = []

				make_Connection(pathI, mul3dxyz)

				//\console.log(pathI)

				maxmpath = mad2.length;

				//for(let i = 0; i < data["sphere"].length; i++){

				// sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material2 );

				//              sphere.position.x = data["sphere"][i][0];

				//            sphere.position.y = data["sphere"][i][1];

				//          sphere.position.z = data["sphere"][i][2];

				//        scene.add( sphere );

				//    }




				//for(let i = 0; i < data["m_points"].length; i++){

				//  sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material2 );

				//  sphere.position.x = data["m_points"][i][0]*5;

				//  sphere.position.y = data["m_points"][i][1]*5 -10;

				//  sphere.position.z = data["m_points"][i][2]*5 + 20;

				//  scene.add( sphere );

				//}




				for (let i = 0; i < mad[mpath].length; i++) {
					sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 8), material3);
					sphere.position.x = i * 5;
					sphere.position.y = mad[mpath][i] * 5 - 10;
					sphere.position.z = -5;
					scene.add(sphere);
				}



				//console.log("mad2");
				//console.log(mad2);
				//
				//  for(let i = 0; i < mad2[mmpath].length; i++){
				//
				//    sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material3 );
				//
				//    sphere.position.x = i*5;
				//
				//    sphere.position.y = mad[mpath][i]*5 -10;
				//
				//    sphere.position.z = mad2[mmpath][i]*2.5 +20;
				//
				//    scene.add( sphere );
				//
				//  }
				//


				for (let mi = 0; mi < mad2.length; mi++) {
					for (let i = 0; i < mad2[mi].length; i++) {
						sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 8), material3);
						sphere.position.x = i * 5;
						sphere.position.y = mad[mpath][i] * 5 - 10;
						sphere.position.z = mad2[mi][i] * 2.5 + 20;
						scene.add(sphere);
					}
				}



				/*
	
				for(let i = 0; i < 14;i++){
	
				  const geometry = new THREE.BufferGeometry();
	
				  console.log(data["connindx"])
	
				  console.log(data["connCol"])
	
				  geometry.setIndex( data["connindx"][i] );
	
				  geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array(data["connXYZ"][i]), 3 ) );
	
				  geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( new Float32Array(data["connCol"][i]), 3 ) );
	
				  const materiall = new THREE.LineBasicMaterial( {
	
				  color: 0xffffff,
	
				  linewidth: 3,
	
				  vertexColors: true,
	
				  alphaToCoverage: true,
	
				} );
	
				const mesh = new THREE.LineSegments( geometry, materiall );
	
				scene.add(mesh);
	
			  }*/

				const geometry = new THREE.BufferGeometry();

				//console.log(data["connindx"])

				//console.log(data["connCol"])

				geometry.setIndex(indx);
				geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ConPoints), 3));
				geometry.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(ConCol), 3));
				const materiall = new THREE.LineBasicMaterial({
					color: 0xffffff,
					linewidth: 5,
					vertexColors: true,
					alphaToCoverage: true,
				});
				const mesh = new THREE.LineSegments(geometry, materiall);
				scene.add(mesh);
				const geometry1 = new THREE.BufferGeometry();

				//console.log(data["connindx"])

				//console.log(data["connCol"])

				const sline = [
					0, -10, 0,
					5 * (nelectron), -10, 0,
					5 * (nelectron), -10, 0,
					5 * (nelectron), 5 * (nelectron) - 10, 1,
					1.25 * (nelectron), -12, 0,
					4.75 * (nelectron), -12, 0,
					4.75 * (nelectron), -12, 0,
					4.75 * (nelectron) - 1, -12 - 1, 0,
					4.75 * (nelectron), -12, 0,
					4.75 * (nelectron) - 1, -12 + 1, 0,

					4.75 * (nelectron), -12, 0,
					4.75 * (nelectron) - 1, -12, 0 - 1,
					4.75 * (nelectron), -12, 0,
					4.75 * (nelectron) - 1, -12, 0 + 1,
					0, 0, 0,
					1, 1, 1,
					0, 0, 0,
					1, 1, 1,
					0, 0, 0,
					1, 1, 1,
					0, 0, 0,
					1, 1, 1,
					0, 0, 0,
					1, 1, 1,
					0, 0, 0,
					1, 1, 1,
				];

				const scolr = [
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.0, 0.0, 0.0,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
				];

				const sindx = [

					//0,1,

					//2,3,

					4, 5,

					6, 7,

					8, 9,

					//10,11,

					//12,13

				];




				geometry1.setIndex(sindx);
				geometry1.setAttribute('position', new THREE.BufferAttribute(new Float32Array(sline), 3));
				geometry1.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(scolr), 3));
				const mesh1 = new THREE.LineSegments(geometry1, materiall);
				scene.add(mesh1);






				const geometry2 = new THREE.BufferGeometry();
				geometry2.setIndex(pathI);
				geometry2.setAttribute('position', new THREE.BufferAttribute(new Float32Array(mul3d), 3));
				geometry2.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(mul3dCol), 3));
				const mesh2 = new THREE.LineSegments(geometry2, materiall);
				scene.add(mesh2);






				const geometry4 = new THREE.BufferGeometry();
				geometry4.setIndex(indx2);
				geometry4.setAttribute('position', new THREE.BufferAttribute(new Float32Array(LinePoint), 3));
				geometry4.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(LineCol), 3));
				const mesh4 = new THREE.LineSegments(geometry4, materiall);
				scene.add(mesh4); //line of s pathways

				const geometry5 = new THREE.BufferGeometry();
				const materiall2 = new THREE.LineBasicMaterial({
					color: 0xffffff,
					linewidth: 2,
					vertexColors: true,
					alphaToCoverage: true,
				});
				console.log(mRefInx)
				geometry5.setIndex(mRefInx);
				geometry5.setAttribute('position', new THREE.BufferAttribute(new Float32Array(mRefxyz), 3));
				geometry5.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(mRefCol), 3));
				const mesh5 = new THREE.LineSegments(geometry5, materiall2);
				scene.add(mesh5);








				const mref = [
					0.0, -10.0, 20.0,
					5 * nelectron, -10.0, 20.0,
					0.0, -10.0, 20.0 + 2.5,//-0.1,
					5 * nelectron, -10.0, 20.0 + 2.5,//-0.1,
					0.0, -10.0, 20.0 + 5,//-0.8,
					5 * nelectron, -10.0, 20.0 + 5,//-0.8,
					0.0, -10.0, 20.0 + 7.5,//-1.3,
					5 * nelectron, -10.0, 20.0 + 7.5,//-1.3,
					0.0, -10.0, 20.0 - 2.5,// -0.5,
					5 * nelectron, -10.0, 20.0 - 2.5,// -0.5,
					0.0, -10.0, 20.0 - 5,// -1.8,
					5 * nelectron, -10.0, 20.0 - 5,// -1.8,
					0.0, -10.0, 20.0 - 7.5,// -3.8,
					5 * nelectron, -10.0, 20.0 - 7.5,// -3.8,
				];

				const mref_colr = [
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
					0.6, 0.6, 0.6,
				];

				const mref_indx = [
					0, 1,
					2, 3,
					4, 5,
					//6,7,
					8, 9,
					10, 11,
					//12,13
				];

				const geometry3 = new THREE.BufferGeometry();
				geometry3.setIndex(mref_indx);
				geometry3.setAttribute('position', new THREE.BufferAttribute(new Float32Array(mref), 3));
				geometry3.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(mref_colr), 3));
				const mesh3 = new THREE.LineSegments(geometry3, materiall);
				scene.add(mesh3);

				const loader = new FontLoader();
				loader.load('fonts/Noto_Sans_Math_Regular.json', function (font) {
				//loader.load('Noto_Sans_Math_Regular.json', function (font) {

					const color = 0x000000;
					const matDark = new THREE.LineBasicMaterial({
						color: color,
						side: THREE.DoubleSide
					});

					const matLite = new THREE.MeshBasicMaterial({
						color: color,
						transparent: true,
						opacity: 0.9,
						side: THREE.DoubleSide
					});

					const messagem = 'o';
					const messagen = 'n';
					const messageo = 'm';




					const shapesm = font.generateShapes(messagem, 7);
					const shapesn = font.generateShapes(messagen, 7);
					const shapeso = font.generateShapes(messageo, 7);




					const geometrym = new THREE.ShapeGeometry(shapesm);
					const geometryn = new THREE.ShapeGeometry(shapesn);
					const geometryo = new THREE.ShapeGeometry(shapeso);




					addSlabel(font, 5 * nelectron + 2);
					textR("Addition of electron", matLite, font, 1.25 * nelectron, -15, 1, 1, -Math.PI / 2, 0, 0);

					//textR("Addition of electron",matLite, font,1.25*nelectron , -15,5,1, 0,0,0 );

					//textR("|",   material3, font,  -6,  -10,   35, 2,   -Math.PI/2,0,0);
					//for(let i = 0; i < mad2[mmpath].length; i++){

					//sphere = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 8 ), material3 );

					//sphere.position.x = i*5;

					//sphere.position.y = mad[mpath][i]*5 -10;

					//sphere.position.z = mad2[mmpath][i]*2.5 +20;

					//scene.add( sphere );


					//}
					let slaterDeterminant = "\\displaylines{";
					for (let j = 0; j < mad2.length; j++) {
						let cg = 1;
						let sl = " ";
						for (let i = 0; i < mad2[j].length; i++) {
							if (i > 0) {
								cg *= CG(mad[mpath][i - 1] * 0.5, 0.5, mad2[j][i - 1] * 0.5, (mad2[j][i] - mad2[j][i - 1]) * 0.5, mad[mpath][i] * 0.5, mad2[j][i] * 0.5)
								if (j == mmpath) {
									//console.log(mad2[j][i] -mad2[j][i-1] )
									if (mad2[j][i] - mad2[j][i - 1] != 1) {
										//textR("\u2191",   material3, font,  -10 - nelectron*2 + 2*i,  -10,  10 -2*mad2.length+ 3*j, 2,   -Math.PI/2,0,0);
										//textR("b",   material3, font,  -10 - nelectron*2 + 2*i,  -10,  10 -2*mad2.length+ 3*j, 2,   -Math.PI/2,0,0);
										sl += "\\downarrow";
									}
									else {
										//textR("\u2193",   material3, font,  -10  - nelectron*2 + 2*i,  -10, 10 -2*mad2.length+  3*j, 2,   -Math.PI/2,0,0);
										//textR("a",   material3, font,  -10 - nelectron*2 + 2*i,  -10,  10 -2*mad2.length+ 3*j, 2,   -Math.PI/2,0,0);
										sl += "\\uparrow";
									}
								}
								else {
									//console.log(mad2[j][i] -mad2[j][i-1] )
									if (mad2[j][i] - mad2[j][i - 1] != 1) {
										//textR("\u2191",   matLite, font,  -10 - nelectron*2 + 2*i,  -10,  10 -2*mad2.length+ 3*j, 2,   -Math.PI/2,0,0);
										//textR("b",   matLite, font,  -10 - nelectron*2 + 2*i,  -10,  10 -2*mad2.length+ 3*j, 2,   -Math.PI/2,0,0);
										sl += "\\downarrow";
									}
									else {
										//textR("\u2193",   matLite, font,  -10  - nelectron*2 + 2*i,  -10, 10-2*mad2.length+  3*j, 2,   -Math.PI/2,0,0);
										//textR("a",   matLite, font,  -10  - nelectron*2 + 2*i,  -10, 10-2*mad2.length+  3*j, 2,   -Math.PI/2,0,0);
										sl += "\\uparrow";
									}
								}
							}
						}
						//textR(parseFloat(cg.toFixed(4)).toString(),   matLite, font,  -10  - nelectron*2 - 10 ,  -10, 10-2*mad2.length+  3*j, 2,   -Math.PI/2,0,0);
						//textR(parseFloat((cg*cg).toFixed(8)).toString(),   matLite, font,  -10  - nelectron*2 - 30 ,  -10, 10-2*mad2.length+  3*j, 2,   -Math.PI/2,0,0);
						//let lg = decimalToFraction(parseFloat((cg*cg)));
						//textR(DecimalToFraction(cg),   matLite, font,  -10  - nelectron*2 - 30 ,  -10, 10-2*mad2.length+  3*j, 1,   -Math.PI/2,0,0);
						//textR((lg.bottom).toString(),   matLite, font,  -10  - nelectron*2 - 30 ,  -10, 10-2*mad2.length+  5*j +2, 1,   -Math.PI/2,0,0);


						//console.log("print");




						const tex = "\\alpha \\beta";
						div.innerHTML = 'ifjoerijfrij';
						if (j % 2 == 0) {
							slaterDeterminant += DecimalToFraction(cg) + "\\vert" + sl + "\\rangle ";

						}
						else {
							slaterDeterminant += DecimalToFraction(cg) + "\\vert" + sl + "\\rangle \\\\";

						}
						console.log(DecimalToFraction(cg) + sl);
					}

					div.style.width = '100%';
					//div.style.height = '360px';
					div.style.fontSize = '90%';
					div.style.backgroundColor = "rbga(0,255,0,0.5)";
					//div.style.opacity= 0.5;
					MathJax.tex2chtmlPromise(slaterDeterminant + "}").then((node) => {
						div.innerHTML = '';
						div.append(node);
						MathJax.startup.document.clear();
						MathJax.startup.document.updateDocument();
					});

					const object = new CSS3DObject(div);
					console.log(object);
					object.position.set(0, 0, 0);
					object.rotation.y = 1;
					mv.appendChild(div);
					waveFunction = slaterDeterminant + "}";


					//textR("\u27e9",   material3, font,  -5 + 2*(nelectron + 1),  -10,   35, 2,   -Math.PI/2,0,0);



					//textR("Wave functions with common final S",matLite, font,5*nelectron + 2 ,  -12,30,1, -Math.PI/2,0,Math.PI/2);

					//textR("2",matLite, font,42 ,  -11.3,6,0.5, 0,Math.PI/2,0);

				});





				controls.update();

				renderer.render(scene, camera);

			});

		}

		function text(messagem, matLite, font, px = 0, py = 0, pz = 0, size = 4) {

			const shapesm = font.generateShapes(messagem, size);

			const geometrym = new THREE.ShapeGeometry(shapesm);



			let text = new THREE.Mesh(geometrym, matLite);

			text.position.y = py;

			text.position.x = px;

			text.position.z = pz;

			text.lookAt(camera.position);

			scene.add(text);

			return text;

		}

		function textR(messagem, matLite, font, px = 0, py = 0, pz = 0, size = 4, rx = 0, ry = 0, rz = 0) {

			const shapesm = font.generateShapes(messagem, size);

			const geometrym = new THREE.ShapeGeometry(shapesm);



			let text = new THREE.Mesh(geometrym, matLite);

			text.position.y = py;

			text.position.x = px;

			text.position.z = pz;

			text.lookAt(camera.position);

			text.rotation.x = rx;

			text.rotation.y = ry;

			text.rotation.z = rz;



			scene.add(text);

			return text;

		}




		function addSlabel(font, x) {

			const color = 0x000000;

			const matLite = new THREE.MeshBasicMaterial({

				color: color,

				transparent: true,

				opacity: 0.9,

				side: THREE.DoubleSide

			});



			//textR("S",   matLite, font,   -8, + 5,  0,  4,   0,0,0);

			//textR("0",   matLite, font,  x , -10,   0, 1,   0,0,0);

			//textR("1/2", matLite, font,  x ,  -5,   0, 1,   0,0,0);

			//textR("1",   matLite, font,  x ,   0,   0, 1,   0,0,0);

			//textR("3/3", matLite, font,  x ,   5,   0, 1,   0,0,0);

			//textR("2",   matLite, font,  x ,  10,   0, 1,   0,0,0);

			//textR("5/2", matLite, font,  x ,  15,   0, 1,   0,0,0);

			//textR("3",   matLite, font,  x ,  20,   0, 1,   0,0,0);

			//textR("7/2", matLite, font,  x ,  25,   0, 1,   0,0,0);

			//textR("4",   matLite, font,  x ,  30,   0, 1,   0,0,0);

			for (let i = 0; i < nelectron + 1; i++) {
				textR("S : " + (i / 2).toString(), matLite, font, x, i * 5 - 10, 0, 1, 0, 0, 0);
			}
			textR("m :+3/2", matLite, font, -5, -10, 5, 1, -Math.PI / 2, 0, 0);
			textR("m :  +1", matLite, font, -5, -10, 15, 1, -Math.PI / 2, 0, 0);
			textR("m :+1/2", matLite, font, -5, -10, 17.5, 1, -Math.PI / 2, 0, 0);
			textR("m :   0", matLite, font, -5, -10, 20, 1, -Math.PI / 2, 0, 0);
			textR("m :-1/2", matLite, font, -5, -10, 22.5, 1, -Math.PI / 2, 0, 0);
			textR("m :  -1", matLite, font, -5, -10, 25, 1, -Math.PI / 2, 0, 0);




		}




		var getImage = document.getElementById("getImage")

		var slider = document.getElementById("myRange");

		var slider2 = document.getElementById("myRange2");

		var slider3 = document.getElementById("myRange3");

		var slider4 = document.getElementById("myRange4");

		var slider5 = document.getElementById("myRange5");



		// var output = document.getElementById("demo");

		// var output2 = document.getElementById("demo2");

		// output.innerHTML = slider.value;

		slider.oninput = function () {
			var vv1 = document.getElementById("nm2");
			vv1.innerHTML = this.value;

			console.log("fiel");

			console.log(slider3.max);

			console.log(scene.children.length);

			for (let i = 0; i < 2000; i++) {

				if (scene.children.length > 5) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}
			finalS = this.value;
			setTimeout(200, firl(nelectron, this.value));

			//slider3.max = maxpath.toString();
			//setTimeout(bail,200);
			//sail();
			//slider4.max = maxmpath.toString();





		}




		slider3.oninput = function () {

			var vv1 = document.getElementById("nm3");
			vv1.innerHTML = this.value;


			mpath = parseInt(this.value);



			console.log(scene.children.length);

			for (let i = 0; i < 2000; i++) {

				if (scene.children.length > 5) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

			setTimeout(100, firl(nelectron, slider.value));
			//setTimeout(bail,200);
			//sail();

			//slider4.max = maxmpath.toString();

		}





		slider4.oninput = function () {


			mmpath = parseInt(this.value);
			var vv1 = document.getElementById("nm4");
			vv1.innerHTML = this.value;


			console.log(slider4.max);

			console.log(scene.children.length);

			for (let i = 0; i < 500; i++) {

				if (scene.children.length > 5) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

			firl(nelectron, slider.value);
			//setTimeout(bail,200);
			//sail();
		}




		slider5.oninput = function () {


			finalM = parseInt(this.value);

			var vv1 = document.getElementById("nm5");
			vv1.innerHTML = this.value;


			console.log(slider5.max);

			console.log(scene.children.length);

			for (let i = 0; i < 500; i++) {

				if (scene.children.length > 5) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

			firl(nelectron, slider.value);
			//setTimeout(bail,200);
			//sail();

		}

		slider2.onclick = function () {

			//output.innerHTML = this.value;

			var enee = document.getElementById("nelec");
			var nvee = document.getElementById("nm1");
			nvee.innerHTML = enee.value;

			console.log(scene.children.length);

			for (let i = 0; i < 500; i++) {

				if (scene.children.length > 5) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

			console.log("Fieleh");

			console.log(enee.value);

			nelectron = parseInt(enee.value);

			firl(parseInt(enee.value), 0);

			//slider.max = nelectron.toString();

			//slider3.max = maxpath.toString();

			//slider4.max = maxmpath.toString();

		}

		function bail() {

			renderer.render(scene, camera);

			var dataURL = renderer.domElement.toDataURL();

			var img = new Image();

			img.src = dataURL;

			//let sp = document.getElementById("demo");

			//sp.appendChild(img);

			const a = document.createElement('a')

			a.href = dataURL;

			//a.download = "PointM"+nelectron.toString()+"_"+finalS.toString()+"_"+mpath.toString()+"_"+finalM.toString()+"_"+mmpath.toString()+".png";

			a.download = "PointS" + nelectron.toString() + "_" + finalS.toString() + "_" + mpath.toString() + "_" + finalM.toString() + "_" + mmpath.toString() + ".png";

			document.body.appendChild(a)

			a.click()

			document.body.removeChild(a)



		}




		getImage.onclick = function () {

			renderer.render(scene, camera);

			var dataURL = renderer.domElement.toDataURL();

			var img = new Image();

			img.src = dataURL;

			//let sp = document.getElementById("demo");

			//sp.appendChild(img);

			const a = document.createElement('a')

			a.href = dataURL;

			a.download = "Point.png";

			document.body.appendChild(a)

			a.click()

			document.body.removeChild(a)

		}

		// getLatex.onclick = function () {
		// 	navigator.clipboard.writeText(waveFunction);
		// }

		function sail() {

			setTimeout(bail, 1000);

		}

		function clean() {

			for (let i = 0; i < 500; i++) {

				if (scene.children.length > 10) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

		}

		function superDlean() {

			for (let i = 0; i < 2000; i++) {

				if (scene.children.length > 1) {

					scene.remove(scene.children[scene.children.length - 1]);

				}

			}

		}

		function makeImage(i, p, j, q) {
			return new Promise((resolve) => {
				setTimeout(() => {
					if (download == 1) {
						bail();
					}
					resolve(i);
				}, 500);
			});
		}
		async function f1() {
			for (let i = 0; i < nelectron / 2 + 1; i++) {
				for (let p = 0; p < maxpath; p++) {
					for (let j = 0; j < 2 * i + 1; j++) {
						//  for (let q = 0; q < maxmpath; q++){
						//let j = 0;
						let q = 0;
						console.log("rioejro")
						console.log(i, p, j, q);
						finalS = i;
						mpath = p;
						finalM = j;
						mmpath = q;
						clean();
						firl(nelectron, i);
						const a = await makeImage(i, p, j, q);
						//await setTimeout(bail,10000);
						//firl(nelectron , finalS);
						//sail();

						//}
					}
				}
			}
		}
		document.body.onkeyup = function (e) {

			let keyPressed = e.which;

			console.log(keyPressed);

			if (keyPressed == 68) {  //uparrow
				console.log(maxmpath)
				console.log(maxpath)
				f1()
			}



			if (keyPressed == 38) {

				slider.value += 1;

				if (slider.value > 2) {

					slider.value = 2

				}

				console.log(slider.value);

				download = 1
			}

			if (keyPressed == 40) {

				slider.value -= 1;

				console.log(slider.value);

				clean();

				firl(nelectron, slider.value);

			}

		}

		function waitingKeypress() {
			return new Promise((resolve) => {
				document.addEventListener('keydown', onKeyHandler);
				function onKeyHandler(e) {
					if (e.keyCode === 38) {
						document.removeEventListener('keydown', onKeyHandler);
						resolve();
					}
				}
			});
		}



		function gcd(a, b) {
			return (b) ? gcd(b, a % b) : a;
		}
		var decimalToFraction = function (_decimal) {
			if (_decimal == parseInt(_decimal)) {
				return {
					top: parseInt(_decimal),
					bottom: 1,
					display: parseInt(_decimal) + '/' + 1
				};
			}
			else {
				var top = _decimal.toString().includes(".") ? _decimal.toString().replace(/\d+[.]/, '') : 0;
				var bottom = Math.pow(10, top.toString().replace('-', '').length);
				if (_decimal >= 1) {
					top = +top + (Math.floor(_decimal) * bottom);
				}
				else if (_decimal <= -1) {
					top = +top + (Math.ceil(_decimal) * bottom);
				}

				var x = Math.abs(gcd(top, bottom));
				return {
					top: (top / x),
					bottom: (bottom / x),
					display: (top / x) + '/' + (bottom / x)
				};
			}
		};



		function onWindowResized() {
			//renderer.setSize(window.innerWidth, window.innerHeight);
			//camera.aspect = window.innerWidth / window.innerHeight;
			//camera.updateProjectionMatrix();
			//const exporter = new EXRExporter();
			//renderer.setRenderTarget;
			//renderTarget.texture.type = THREE.HalfFloatType;
			//const option = {type: THREE.HalfFloatType, compression}
			renderer.render(scene, camera);
			//var dataURL = renderer.domElement.toDataURL();
			//var img = new Image();
			//img.src = dataURL;
			//let sp = document.getElementById("root");
			//sp.appendChild(img);
		}

		function animation(msTime) {

			cubeCamera.rotation.x += 0.1;
			//cubeCamera.update( renderer, scene );
			scene.rotation.x = 0.4 + 0.1 * Math.cos(0.005 * (msTime % 10000));
			scene.rotation.y = 0.4 + 0.1 * Math.cos(0.005 * (msTime % 10000));
			controls.update();
			renderer.render(scene, camera);
			//stats.update();
		}


		function CG(j1, j2, m1, m2, j3, m3) {
			return Module.ccall("CG", "number", ["number", "number", "number", "number", "number", "number"], [j1, j2, m1, m2, j3, m3]);
		}


		function DecimalToFraction(j1) {
			return Module.ccall("DecToFrac", "string", ["number"], [j1]);
		}

	</script>

	<script src="cgcCALC.js"></script>
</body>

</html>
